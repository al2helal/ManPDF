\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{longtable,booktabs}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Archive::Zip(3pm)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
\usepackage{pagecolor}

% Set background colour (of the page)
\definecolor{weirdbgcolor}{HTML}{FCF4F0}
\pagecolor{weirdbgcolor}

% Make bold text appear in a particular colour
\definecolor{boldcolor}{HTML}{6E0002}
\let\realtextbf=\textbf
\renewcommand{\textbf}[1]{\textcolor{boldcolor}{\realtextbf{#1}}}

% Use underlines instead of emphasis (ugh)
\renewcommand{\emph}[1]{\underline{#1}}

% % Use fixed-width font by default
% \renewcommand*\familydefault{\ttdefault}

\title{Archive::Zip(3pm)}
\author{}
\date{}

\begin{document}
\maketitle

\begin{longtable}[c]{@{}lll@{}}
\toprule\addlinespace
Archive::Zip(3pm) & User Contributed Perl Documentation &
Archive::Zip(3pm)
\\\addlinespace
\bottomrule
\end{longtable}

\hyperdef{}{NAME}{\section{\hyperref[NAME]{NAME}}\label{NAME}}

Archive::Zip - Provide an interface to ZIP archive files.

\hyperdef{}{SYNOPSIS}{\section{\hyperref[SYNOPSIS]{SYNOPSIS}}\label{SYNOPSIS}}

\begin{verbatim}
   # Create a Zip file
   use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
   my $zip = Archive::Zip->new();
   
   # Add a directory
   my $dir_member = $zip->addDirectory( 'dirname/' );
   
   # Add a file from a string with compression
   my $string_member = $zip->addString( 'This is a test', 'stringMember.txt' );
   $string_member->desiredCompressionMethod( COMPRESSION_DEFLATED );
   
   # Add a file from disk
   my $file_member = $zip->addFile( 'xyz.pl', 'AnotherName.pl' );
   
   # Save the Zip file
   unless ( $zip->writeToFileNamed('someZip.zip') == AZ_OK ) {
       die 'write error';
   }
   
   # Read a Zip file
   my $somezip = Archive::Zip->new();
   unless ( $somezip->read( 'someZip.zip' ) == AZ_OK ) {
       die 'read error';
   }
   
   # Change the compression type for a file in the Zip
   my $member = $somezip->memberNamed( 'stringMember.txt' );
   $member->desiredCompressionMethod( COMPRESSION_STORED );
   unless ( $zip->writeToFileNamed( 'someOtherZip.zip' ) == AZ_OK ) {
       die 'write error';
   }
\end{verbatim}

\hyperdef{}{DESCRIPTION}{\section{\hyperref[DESCRIPTION]{DESCRIPTION}}\label{DESCRIPTION}}

The Archive::Zip module allows a Perl program to create, manipulate,
read, and write Zip archive files.

Zip archives can be created, or you can read from existing zip files.

Once created, they can be written to files, streams, or strings. Members
can be added, removed, extracted, replaced, rearranged, and enumerated.
They can also be renamed or have their dates, comments, or other
attributes queried or modified. Their data can be compressed or
uncompressed as needed.

Members can be created from members in existing Zip files, or from
existing directories, files, or strings.

This module uses the Compress::Raw::Zlib library to read and write the
compressed streams inside the files.

One can use Archive::Zip::MemberRead to read the zip file archive
members as if they were files.

\hyperdef{}{Fileux5fNaming}{\subsection{\hyperref[Fileux5fNaming]{File
Naming}}\label{Fileux5fNaming}}

Regardless of what your local file system uses for file naming, names in
a Zip file are in Unix format ( \emph{forward} slashes (/) separating
directory names, etc.).

``Archive::Zip'' tries to be consistent with file naming conventions,
and will translate back and forth between native and Zip file names.

However, it can't guess which format names are in. So two rules control
what kind of file name you must pass various routines:

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[Names of files are in local format.]
``File::Spec'' and ``File::Basename'' are used for various file
operations. When you're referring to a file on your system, use its file
naming conventions.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[Names of archive members are in Unix format.]
This applies to every method that refers to an archive member, or
provides a name for new archive members. The ``extract()'' methods that
can take one or two names will convert from local to zip names if you
call them with a single name.
\end{description}

\hyperdef{}{Archive::Zipux5fObjectux5fModel}{\subsection{\hyperref[Archive::Zipux5fObjectux5fModel]{Archive::Zip
Object Model}}\label{Archive::Zipux5fObjectux5fModel}}

\hyperdef{}{Overview}{\subsection{\hyperref[Overview]{Overview}}\label{Overview}}

Archive::Zip::Archive objects are what you ordinarily deal with. These
maintain the structure of a zip file, without necessarily holding data.
When a zip is read from a disk file, the (possibly compressed) data
still lives in the file, not in memory. Archive members hold information
about the individual members, but not (usually) the actual member data.
When the zip is written to a (different) file, the member data is
compressed or copied as needed. It is possible to make archive members
whose data is held in a string in memory, but this is not done when a
zip file is read. Directory members don't have any data.

\hyperdef{}{Inheritance}{\subsection{\hyperref[Inheritance]{Inheritance}}\label{Inheritance}}

\begin{verbatim}
  Exporter
   Archive::Zip                            Common base class, has defs.
       Archive::Zip::Archive               A Zip archive.
       Archive::Zip::Member                Abstract superclass for all members.
           Archive::Zip::StringMember      Member made from a string
           Archive::Zip::FileMember        Member made from an external file
               Archive::Zip::ZipFileMember Member that lives in a zip file
               Archive::Zip::NewFileMember Member whose data is in a file
           Archive::Zip::DirectoryMember   Member that is a directory
\end{verbatim}

\hyperdef{}{EXPORTS}{\section{\hyperref[EXPORTS]{EXPORTS}}\label{EXPORTS}}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[:CONSTANTS]
Exports the following constants:

~

FA\_MSDOS FA\_UNIX GPBF\_ENCRYPTED\_MASK
GPBF\_DEFLATING\_COMPRESSION\_MASK GPBF\_HAS\_DATA\_DESCRIPTOR\_MASK
COMPRESSION\_STORED COMPRESSION\_DEFLATED IFA\_TEXT\_FILE\_MASK
IFA\_TEXT\_FILE IFA\_BINARY\_FILE COMPRESSION\_LEVEL\_NONE
COMPRESSION\_LEVEL\_DEFAULT COMPRESSION\_LEVEL\_FASTEST
COMPRESSION\_LEVEL\_BEST\_COMPRESSION
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[:MISC\_CONSTANTS]
Exports the following constants (only necessary for extending the
module):

~

FA\_AMIGA FA\_VAX\_VMS FA\_VM\_CMS FA\_ATARI\_ST FA\_OS2\_HPFS
FA\_MACINTOSH FA\_Z\_SYSTEM FA\_CPM FA\_WINDOWS\_NTFS
GPBF\_IMPLODING\_8K\_SLIDING\_DICTIONARY\_MASK
GPBF\_IMPLODING\_3\_SHANNON\_FANO\_TREES\_MASK
GPBF\_IS\_COMPRESSED\_PATCHED\_DATA\_MASK COMPRESSION\_SHRUNK
DEFLATING\_COMPRESSION\_NORMAL DEFLATING\_COMPRESSION\_MAXIMUM
DEFLATING\_COMPRESSION\_FAST DEFLATING\_COMPRESSION\_SUPER\_FAST
COMPRESSION\_REDUCED\_1 COMPRESSION\_REDUCED\_2 COMPRESSION\_REDUCED\_3
COMPRESSION\_REDUCED\_4 COMPRESSION\_IMPLODED COMPRESSION\_TOKENIZED
COMPRESSION\_DEFLATED\_ENHANCED
COMPRESSION\_PKWARE\_DATA\_COMPRESSION\_LIBRARY\_IMPLODED
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[:ERROR\_CODES]
Explained below. Returned from most methods.

~

AZ\_OK AZ\_STREAM\_END AZ\_ERROR AZ\_FORMAT\_ERROR AZ\_IO\_ERROR
\end{description}

\hyperdef{}{ERRORux5fCODES}{\section{\hyperref[ERRORux5fCODES]{ERROR
CODES}}\label{ERRORux5fCODES}}

Many of the methods in Archive::Zip return error codes. These are
implemented as inline subroutines, using the ``use constant'' pragma.
They can be imported into your namespace using the ``:ERROR\_CODES''
tag:

\begin{verbatim}
  use Archive::Zip qw( :ERROR_CODES );
  
  ...
  
  unless ( $zip->read( 'myfile.zip' ) == AZ_OK ) {
      die "whoops!";
  }
\end{verbatim}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[AZ\_OK (0)]
Everything is fine.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[AZ\_STREAM\_END (1)]
The read stream (or central directory) ended normally.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[AZ\_ERROR (2)]
There was some generic kind of error.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[AZ\_FORMAT\_ERROR (3)]
There is a format error in a ZIP file being read.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[AZ\_IO\_ERROR (4)]
There was an IO error.
\end{description}

\hyperdef{}{Compression}{\subsection{\hyperref[Compression]{Compression}}\label{Compression}}

Archive::Zip allows each member of a ZIP file to be compressed (using
the Deflate algorithm) or uncompressed.

Other compression algorithms that some versions of ZIP have been able to
produce are not supported. Each member has two compression methods: the
one it's stored as (this is always COMPRESSION\_STORED for string and
external file members), and the one you desire for the member in the zip
file.

These can be different, of course, so you can make a zip member that is
not compressed out of one that is, and vice versa.

You can inquire about the current compression and set the desired
compression method:

\begin{verbatim}
  my $member = $zip->memberNamed( 'xyz.txt' );
  $member->compressionMethod();    # return current compression
  
  # set to read uncompressed
  $member->desiredCompressionMethod( COMPRESSION_STORED );
  
  # set to read compressed
  $member->desiredCompressionMethod( COMPRESSION_DEFLATED );
\end{verbatim}

There are two different compression methods:

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[COMPRESSION\_STORED]
File is stored (no compression)
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[COMPRESSION\_DEFLATED]
File is Deflated
\end{description}

\hyperdef{}{Compressionux5fLevels}{\subsection{\hyperref[Compressionux5fLevels]{Compression
Levels}}\label{Compressionux5fLevels}}

If a member's desiredCompressionMethod is COMPRESSION\_DEFLATED, you can
choose different compression levels. This choice may affect the speed of
compression and decompression, as well as the size of the compressed
member data.

\begin{verbatim}
  $member->desiredCompressionLevel( 9 );
\end{verbatim}

The levels given can be:

\begin{description}
\item[0 or COMPRESSION\_LEVEL\_NONE]
This is the same as saying

~

\begin{verbatim}
  $member->desiredCompressionMethod( COMPRESSION_STORED );
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[1 .. 9]
1 gives the best speed and worst compression, and 9 gives the best
compression and worst speed.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[COMPRESSION\_LEVEL\_FASTEST]
This is a synonym for level 1.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[COMPRESSION\_LEVEL\_BEST\_COMPRESSION]
This is a synonym for level 9.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[COMPRESSION\_LEVEL\_DEFAULT]
This gives a good compromise between speed and compression, and is
currently equivalent to 6 (this is in the zlib code). This is the level
that will be used if not specified.
\end{description}

\hyperdef{}{Archive::Zipux5fMethods}{\section{\hyperref[Archive::Zipux5fMethods]{Archive::Zip
Methods}}\label{Archive::Zipux5fMethods}}

The Archive::Zip class (and its invisible subclass
Archive::Zip::Archive) implement generic zip file functionality.
Creating a new Archive::Zip object actually makes an
Archive::Zip::Archive object, but you don't have to worry about this
unless you're subclassing.

\hyperdef{}{Constructor}{\subsection{\hyperref[Constructor]{Constructor}}\label{Constructor}}

\begin{description}
\item[new( {[}\$fileName{]} )]
Make a new, empty zip archive.

~

\begin{verbatim}
    my $zip = Archive::Zip->new();
    
\end{verbatim}

~

If an additional argument is passed, \emph{new()} will call
\emph{read()} to read the contents of an archive:

~

\begin{verbatim}
    my $zip = Archive::Zip->new( 'xyz.zip' );
    
\end{verbatim}

~

If a filename argument is passed and the read fails for any reason, new
will return undef. For this reason, it may be better to call read
separately.
\end{description}

\hyperdef{}{Zipux5fArchiveux5fUtilityux5fMethods}{\subsection{\hyperref[Zipux5fArchiveux5fUtilityux5fMethods]{Zip
Archive Utility Methods}}\label{Zipux5fArchiveux5fUtilityux5fMethods}}

These Archive::Zip methods may be called as functions or as object
methods. Do not call them as class methods:

\begin{verbatim}
    $zip = Archive::Zip->new();
    $crc = Archive::Zip::computeCRC32( 'ghijkl' );    # OK
    $crc = $zip->computeCRC32( 'ghijkl' );            # also OK
    $crc = Archive::Zip->computeCRC32( 'ghijkl' );    # NOT OK
\end{verbatim}

\begin{description}
\item[Archive::Zip::computeCRC32( \$string {[}, \$crc{]} )]
This is a utility function that uses the Compress::Raw::Zlib CRC routine
to compute a CRC-32. You can get the CRC of a string:

~

\begin{verbatim}
    $crc = Archive::Zip::computeCRC32( $string );
    
\end{verbatim}

~

Or you can compute the running CRC:

~

\begin{verbatim}
    $crc = 0;
    $crc = Archive::Zip::computeCRC32( 'abcdef', $crc );
    $crc = Archive::Zip::computeCRC32( 'ghijkl', $crc );
    
\end{verbatim}
\end{description}

\begin{description}
\item[Archive::Zip::setChunkSize( \$number )]
Report or change chunk size used for reading and writing. This can make
big differences in dealing with large files. Currently, this defaults to
32K. This also changes the chunk size used for Compress::Raw::Zlib. You
must call \emph{setChunkSize()} before reading or writing. This is not
exportable, so you must call it like:

~

\begin{verbatim}
    Archive::Zip::setChunkSize( 4096 );
    
\end{verbatim}

~

or as a method on a zip (though this is a global setting). Returns old
chunk size.
\end{description}

\begin{description}
\item[\emph{Archive::Zip::chunkSize()}]
Returns the current chunk size:

~

\begin{verbatim}
    my $chunkSize = Archive::Zip::chunkSize();
    
\end{verbatim}
\end{description}

\begin{description}
\item[Archive::Zip::setErrorHandler( \textbackslash{}\&subroutine )]
Change the subroutine called with error strings. This defaults to
\textbackslash{}\&Carp::carp, but you may want to change it to get the
error strings. This is not exportable, so you must call it like:

~

\begin{verbatim}
    Archive::Zip::setErrorHandler( \&myErrorHandler );
    
\end{verbatim}

~

If myErrorHandler is undef, resets handler to default. Returns old error
handler. Note that if you call Carp::carp or a similar routine or if
you're chaining to the default error handler from your error handler,
you may want to increment the number of caller levels that are skipped
(do not just set it to a number):

~

\begin{verbatim}
    $Carp::CarpLevel++;
    
\end{verbatim}
\end{description}

\begin{description}
\item[Archive::Zip::tempFile( {[}\$tmpdir{]} )]
Create a uniquely named temp file. It will be returned open for
read/write. If \$tmpdir is given, it is used as the name of a directory
to create the file in. If not given, creates the file using
``File::Spec::tmpdir()''. Generally, you can override this choice using
the

~

\begin{verbatim}
    $ENV{TMPDIR}
    
\end{verbatim}

~

environment variable. But see the File::Spec documentation for your
system. Note that on many systems, if you're running in taint mode, then
you must make sure that \$ENV\{TMPDIR\} is untainted for it to be used.
Will \emph{NOT} create \$tmpdir if it doesn't exist (this is a change
from prior versions!). Returns file handle and name:

~

\begin{verbatim}
    my ($fh, $name) = Archive::Zip::tempFile();
    my ($fh, $name) = Archive::Zip::tempFile('myTempDir');
    my $fh = Archive::Zip::tempFile();  # if you don't need the name
    
\end{verbatim}
\end{description}

\hyperdef{}{Zipux5fArchiveux5fAccessors}{\subsection{\hyperref[Zipux5fArchiveux5fAccessors]{Zip
Archive Accessors}}\label{Zipux5fArchiveux5fAccessors}}

\begin{description}
\item[\emph{members()}]
Return a copy of the members array

~

\begin{verbatim}
    my @members = $zip->members();
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{numberOfMembers()}]
Return the number of members I have
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{memberNames()}]
Return a list of the (internal) file names of the zip members
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[memberNamed( \$string )]
Return ref to member whose filename equals given filename or undef.
\$string must be in Zip (Unix) filename format.
\end{description}

\begin{description}
\item[membersMatching( \$regex )]
Return array of members whose filenames match given regular expression
in list context. Returns number of matching members in scalar context.

~

\begin{verbatim}
    my @textFileMembers = $zip->membersMatching( '.*\.txt' );
    # or
    my $numberOfTextFiles = $zip->membersMatching( '.*\.txt' );
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{diskNumber()}]
Return the disk that I start on. Not used for writing zips, but might be
interesting if you read a zip in. This should be 0, as Archive::Zip does
not handle multi-volume archives.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{diskNumberWithStartOfCentralDirectory()}]
Return the disk number that holds the beginning of the central
directory. Not used for writing zips, but might be interesting if you
read a zip in. This should be 0, as Archive::Zip does not handle
multi-volume archives.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{numberOfCentralDirectoriesOnThisDisk()}]
Return the number of CD structures in the zipfile last read in. Not used
for writing zips, but might be interesting if you read a zip in.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{numberOfCentralDirectories()}]
Return the number of CD structures in the zipfile last read in. Not used
for writing zips, but might be interesting if you read a zip in.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{centralDirectorySize()}]
Returns central directory size, as read from an external zip file. Not
used for writing zips, but might be interesting if you read a zip in.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{centralDirectoryOffsetWRTStartingDiskNumber()}]
Returns the offset into the zip file where the CD begins. Not used for
writing zips, but might be interesting if you read a zip in.
\end{description}

\begin{description}
\item[zipfileComment( {[}\$string{]} )]
Get or set the zipfile comment. Returns the old comment.

~

\begin{verbatim}
    print $zip->zipfileComment();
    $zip->zipfileComment( 'New Comment' );
    
\end{verbatim}
\end{description}

\begin{description}
\item[\emph{eocdOffset()}]
Returns the (unexpected) number of bytes between where the EOCD was
found and where it expected to be. This is normally 0, but would be
positive if something (a virus, perhaps) had added bytes somewhere
before the EOCD. Not used for writing zips, but might be interesting if
you read a zip in. Here is an example of how you can diagnose this:

~

\begin{verbatim}
  my $zip = Archive::Zip->new('somefile.zip');
  if ($zip->eocdOffset())
  {
    warn "A virus has added ", $zip->eocdOffset, " bytes of garbage\n";
  }
    
\end{verbatim}

~

The ``eocdOffset()'' is used to adjust the starting position of member
headers, if necessary.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{fileName()}]
Returns the name of the file last read from. If nothing has been read
yet, returns an empty string; if read from a file handle, returns the
handle in string form.
\end{description}

\hyperdef{}{Zipux5fArchiveux5fMemberux5fOperations}{\subsection{\hyperref[Zipux5fArchiveux5fMemberux5fOperations]{Zip
Archive Member
Operations}}\label{Zipux5fArchiveux5fMemberux5fOperations}}

Various operations on a zip file modify members. When a member is passed
as an argument, you can either use a reference to the member itself, or
the name of a member. Of course, using the name requires that names be
unique within a zip (this is not enforced).

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[removeMember( \$memberOrName )]
Remove and return the given member, or match its name and remove it.
Returns undef if member or name doesn't exist in this Zip. No-op if
member does not belong to this zip.
\end{description}

\begin{description}
\item[replaceMember( \$memberOrName, \$newMember )]
Remove and return the given member, or match its name and remove it.
Replace with new member. Returns undef if member or name doesn't exist
in this Zip, or if \$newMember is undefined.

~

It is an (undiagnosed) error to provide a \$newMember that is a member
of the zip being modified.

~

\begin{verbatim}
    my $member1 = $zip->removeMember( 'xyz' );
    my $member2 = $zip->replaceMember( 'abc', $member1 );
    # now, $member2 (named 'abc') is not in $zip,
    # and $member1 (named 'xyz') is, having taken $member2's place.
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[extractMember( \$memberOrName {[}, \$extractedName {]} )]
Extract the given member, or match its name and extract it. Returns
undef if member doesn't exist in this Zip. If optional second arg is
given, use it as the name of the extracted member. Otherwise, the
internal filename of the member is used as the name of the extracted
file or directory. If you pass \$extractedName, it should be in the
local file system's format. All necessary directories will be created.
Returns ``AZ\_OK'' on success.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[extractMemberWithoutPaths( \$memberOrName {[}, \$extractedName {]}
)]
Extract the given member, or match its name and extract it. Does not use
path information (extracts into the current directory). Returns undef if
member doesn't exist in this Zip. If optional second arg is given, use
it as the name of the extracted member (its paths will be deleted too).
Otherwise, the internal filename of the member (minus paths) is used as
the name of the extracted file or directory. Returns ``AZ\_OK'' on
success.
\end{description}

\begin{description}
\item[addMember( \$member )]
Append a member (possibly from another zip file) to the zip file.
Returns the new member. Generally, you will use \emph{addFile()},
\emph{addDirectory()}, \emph{addFileOrDirectory()}, \emph{addString()},
or \emph{read()} to add members.

~

\begin{verbatim}
    # Move member named 'abc' to end of zip:
    my $member = $zip->removeMember( 'abc' );
    $zip->addMember( $member );
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[updateMember( \$memberOrName, \$fileName )]
Update a single member from the file or directory named \$fileName.
Returns the (possibly added or updated) member, if any; ``undef'' on
errors. The comparison is based on ``lastModTime()'' and (in the case of
a non-directory) the size of the file.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[addFile( \$fileName {[}, \$newName {]} )]
Append a member whose data comes from an external file, returning the
member or undef. The member will have its file name set to the name of
the external file, and its desiredCompressionMethod set to
COMPRESSION\_DEFLATED. The file attributes and last modification time
will be set from the file. If the name given does not represent a
readable plain file or symbolic link, undef will be returned. \$fileName
must be in the format required for the local file system. The optional
\$newName argument sets the internal file name to something different
than the given \$fileName. \$newName, if given, must be in Zip name
format (i.e. Unix). The text mode bit will be set if the contents
appears to be text (as returned by the ``-T'' perl operator).

~

\emph{NOTE} that you shouldn't (generally) use absolute path names in
zip member names, as this will cause problems with some zip tools as
well as introduce a security hole and make the zip harder to use.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[addDirectory( \$directoryName {[}, \$fileName {]} )]
Append a member created from the given directory name. The directory
name does not have to name an existing directory. If the named directory
exists, the file modification time and permissions are set from the
existing directory, otherwise they are set to now and permissive default
permissions. \$directoryName must be in local file system format. The
optional second argument sets the name of the archive member (which
defaults to \$directoryName). If given, it must be in Zip (Unix) format.
Returns the new member.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[addFileOrDirectory( \$name {[}, \$newName {]} )]
Append a member from the file or directory named \$name. If \$newName is
given, use it for the name of the new member. Will add or remove
trailing slashes from \$newName as needed. \$name must be in local file
system format. The optional second argument sets the name of the archive
member (which defaults to \$name). If given, it must be in Zip (Unix)
format.
\end{description}

\begin{description}
\item[addString( \$stringOrStringRef, \$name )]
Append a member created from the given string or string reference. The
name is given by the second argument. Returns the new member. The last
modification time will be set to now, and the file attributes will be
set to permissive defaults.

~

\begin{verbatim}
    my $member = $zip->addString( 'This is a test', 'test.txt' );
    
\end{verbatim}
\end{description}

\begin{description}
\item[contents( \$memberOrMemberName {[}, \$newContents {]} )]
Returns the uncompressed data for a particular member, or undef.

~

\begin{verbatim}
    print "xyz.txt contains " . $zip->contents( 'xyz.txt' );
    
\end{verbatim}

~

Also can change the contents of a member:

~

\begin{verbatim}
    $zip->contents( 'xyz.txt', 'This is the new contents' );
    
\end{verbatim}

~

If called expecting an array as the return value, it will include the
status as the second value in the array.

~

\begin{verbatim}
    ($content, $status) = $zip->contents( 'xyz.txt');
    
\end{verbatim}
\end{description}

\hyperdef{}{Zipux5fArchiveux5fIux2fOux5foperations}{\subsection{\hyperref[Zipux5fArchiveux5fIux2fOux5foperations]{Zip
Archive I/O operations}}\label{Zipux5fArchiveux5fIux2fOux5foperations}}

A Zip archive can be written to a file or file handle, or read from one.

\begin{description}
\item[writeToFileNamed( \$fileName )]
Write a zip archive to named file. Returns ``AZ\_OK'' on success.

~

\begin{verbatim}
    my $status = $zip->writeToFileNamed( 'xx.zip' );
    die "error somewhere" if $status != AZ_OK;
    
\end{verbatim}

~

Note that if you use the same name as an existing zip file that you read
in, you will clobber ZipFileMembers. So instead, write to a different
file name, then delete the original. If you use the ``overwrite()'' or
``overwriteAs()'' methods, you can re-write the original zip in this
way. \$fileName should be a valid file name on your system.
\end{description}

\begin{description}
\item[writeToFileHandle( \$fileHandle {[}, \$seekable{]} )]
Write a zip archive to a file handle. Return AZ\_OK on success. The
optional second arg tells whether or not to try to seek backwards to
re-write headers. If not provided, it is set if the Perl ``-f'' test
returns true. This could fail on some operating systems, though.

~

\begin{verbatim}
    my $fh = IO::File->new( 'someFile.zip', 'w' );
    unless ( $zip->writeToFileHandle( $fh ) == AZ_OK ) {
        # error handling
    }
    
\end{verbatim}

~

If you pass a file handle that is not seekable (like if you're writing
to a pipe or a socket), pass a false second argument:

~

\begin{verbatim}
    my $fh = IO::File->new( '| cat > somefile.zip', 'w' );
    $zip->writeToFileHandle( $fh, 0 );   # fh is not seekable
    
\end{verbatim}

~

If this method fails during the write of a member, that member and all
following it will return false from ``wasWritten()''. See
\emph{writeCentralDirectory()} for a way to deal with this. If you want,
you can write data to the file handle before passing it to
\emph{writeToFileHandle()}; this could be used (for instance) for making
self-extracting archives. However, this only works reliably when writing
to a real file (as opposed to STDOUT or some other possible non-file).

~

See examples/selfex.pl for how to write a self-extracting archive.
\end{description}

\begin{description}
\item[writeCentralDirectory( \$fileHandle {[}, \$offset {]} )]
Writes the central directory structure to the given file handle.

~

Returns AZ\_OK on success. If given an \$offset, will seek to that point
before writing. This can be used for recovery in cases where
writeToFileHandle or writeToFileNamed returns an IO error because of
running out of space on the destination file.

~

You can truncate the zip by seeking backwards and then writing the
directory:

~

\begin{verbatim}
    my $fh = IO::File->new( 'someFile.zip', 'w' );
        my $retval = $zip->writeToFileHandle( $fh );
    if ( $retval == AZ_IO_ERROR ) {
        my @unwritten = grep { not $_->wasWritten() } $zip->members();
        if (@unwritten) {
            $zip->removeMember( $member ) foreach my $member ( @unwritten );
            $zip->writeCentralDirectory( $fh,
            $unwritten[0]->writeLocalHeaderRelativeOffset());
        }
    }
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[overwriteAs( \$newName )]
Write the zip to the specified file, as safely as possible. This is done
by first writing to a temp file, then renaming the original if it
exists, then renaming the temp file, then deleting the renamed original
if it exists. Returns AZ\_OK if successful.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{overwrite()}]
Write back to the original zip file. See \emph{overwriteAs()} above. If
the zip was not ever read from a file, this generates an error.
\end{description}

\begin{description}
\item[read( \$fileName )]
Read zipfile headers from a zip file, appending new members. Returns
``AZ\_OK'' or error code.

~

\begin{verbatim}
    my $zipFile = Archive::Zip->new();
    my $status = $zipFile->read( '/some/FileName.zip' );
    
\end{verbatim}
\end{description}

\begin{description}
\item[readFromFileHandle( \$fileHandle, \$filename )]
Read zipfile headers from an already-opened file handle, appending new
members. Does not close the file handle. Returns ``AZ\_OK'' or error
code. Note that this requires a seekable file handle; reading from a
stream is not yet supported.

~

\begin{verbatim}
    my $fh = IO::File->new( '/some/FileName.zip', 'r' );
    my $zip1 = Archive::Zip->new();
    my $status = $zip1->readFromFileHandle( $fh );
    my $zip2 = Archive::Zip->new();
    $status = $zip2->readFromFileHandle( $fh );
    
\end{verbatim}
\end{description}

\hyperdef{}{Zipux5fArchiveux5fTreeux5foperations}{\subsection{\hyperref[Zipux5fArchiveux5fTreeux5foperations]{Zip
Archive Tree operations}}\label{Zipux5fArchiveux5fTreeux5foperations}}

These used to be in Archive::Zip::Tree but got moved into Archive::Zip.
They enable operation on an entire tree of members or files. A usage
example:

\begin{verbatim}
  use Archive::Zip;
  my $zip = Archive::Zip->new();
  
  # add all readable files and directories below . as xyz/*
  $zip->addTree( '.', 'xyz' );
  
  # add all readable plain files below /abc as def/*
  $zip->addTree( '/abc', 'def', sub { -f && -r } );
  
  # add all .c files below /tmp as stuff/*
  $zip->addTreeMatching( '/tmp', 'stuff', '\.c$' );
  
  # add all .o files below /tmp as stuff/* if they aren't writable
  $zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { ! -w } );
  
  # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
  $zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { -s < 200 } );
  
  # and write them into a file
  $zip->writeToFileNamed('xxx.zip');
  
  # now extract the same files into /tmpx
  $zip->extractTree( 'stuff', '/tmpx' );
\end{verbatim}

\begin{description}
\item[\$zip-\textgreater{}addTree( \$root, \$dest {[},\$pred{]} ) -- Add
tree of files to a zip]
\$root is the root of the tree of files and directories to be added. It
is a valid directory name on your system. \$dest is the name for the
root in the zip file (undef or blank means to use relative pathnames).
It is a valid ZIP directory name (that is, it uses forward slashes (/)
for separating directory components). \$pred is an optional subroutine
reference to select files: it is passed the name of the prospective file
or directory using \$\_, and if it returns true, the file or directory
will be included. The default is to add all readable files and
directories. For instance, using

~

\begin{verbatim}
  my $pred = sub { /\.txt/ };
  $zip->addTree( '.', '', $pred );
    
\end{verbatim}

~

will add all the .txt files in and below the current directory, using
relative names, and making the names identical in the zipfile:

~

\begin{verbatim}
  original name           zip member name
  ./xyz                   xyz
  ./a/                    a/
  ./a/b                   a/b
    
\end{verbatim}

~

To translate absolute to relative pathnames, just pass them in:
\$zip-\textgreater{}addTree( `/c/d', `a' );

~

\begin{verbatim}
  original name           zip member name
  /c/d/xyz                a/xyz
  /c/d/a/                 a/a/
  /c/d/a/b                a/a/b
    
\end{verbatim}

~

Returns AZ\_OK on success. Note that this will not follow symbolic links
to directories. Note also that this does not check for the validity of
filenames.

~

Note that you generally \emph{don't} want to make zip archive member
names absolute.
\end{description}

\begin{description}
\item[\$zip-\textgreater{}addTreeMatching( \$root, \$dest, \$pattern
{[},\$pred{]} )]
\$root is the root of the tree of files and directories to be added
\$dest is the name for the root in the zip file (undef means to use
relative pathnames) \$pattern is a (non-anchored) regular expression for
filenames to match \$pred is an optional subroutine reference to select
files: it is passed the name of the prospective file or directory in
\$\_, and if it returns true, the file or directory will be included.
The default is to add all readable files and directories. To add all
files in and below the current dirctory whose names end in ``.pl'', and
make them extract into a subdirectory named ``xyz'', do this:

~

\begin{verbatim}
  $zip->addTreeMatching( '.', 'xyz', '\.pl$' )
    
\end{verbatim}

~

To add all \emph{writable} files in and below the dirctory named
``/abc'' whose names end in ``.pl'', and make them extract into a
subdirectory named ``xyz'', do this:

~

\begin{verbatim}
  $zip->addTreeMatching( '/abc', 'xyz', '\.pl$', sub { -w } )
    
\end{verbatim}

~

Returns AZ\_OK on success. Note that this will not follow symbolic links
to directories.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\$zip-\textgreater{}updateTree( \$root, {[} \$dest, {[} \$pred
{[}, \$mirror{]}{]}{]} );]
Update a zip file from a directory tree.

~

``updateTree()'' takes the same arguments as ``addTree()'', but first
checks to see whether the file or directory already exists in the zip
file, and whether it has been changed.

~

If the fourth argument \$mirror is true, then delete all my members if
corresponding files weren't found.

~

Returns an error code or AZ\_OK if all is well.
\end{description}

\begin{description}
\item[\$zip-\textgreater{}\emph{extractTree()}]
\end{description}

\begin{description}
\item[\$zip-\textgreater{}extractTree( \$root )]
\end{description}

\begin{description}
\item[\$zip-\textgreater{}extractTree( \$root, \$dest )]
\end{description}

\begin{description}
\item[\$zip-\textgreater{}extractTree( \$root, \$dest, \$volume )]
If you don't give any arguments at all, will extract all the files in
the zip with their original names.

~

If you supply one argument for \$root, ``extractTree'' will extract all
the members whose names start with \$root into the current directory,
stripping off \$root first. \$root is in Zip (Unix) format. For
instance,

~

\begin{verbatim}
  $zip->extractTree( 'a' );
    
\end{verbatim}

~

when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will
extract:

~

a/x as ./x

~

a/b/c as ./b/c

~

If you give two arguments, ``extractTree'' extracts all the members
whose names start with \$root. It will translate \$root into \$dest to
construct the destination file name. \$root and \$dest are in Zip (Unix)
format. For instance,

~

\begin{verbatim}
   $zip->extractTree( 'a', 'd/e' );
    
\end{verbatim}

~

when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will
extract:

~

a/x to d/e/x

~

a/b/c to d/e/b/c and ignore ax/d/e and d/e

~

If you give three arguments, ``extractTree'' extracts all the members
whose names start with \$root. It will translate \$root into \$dest to
construct the destination file name, and then it will convert to local
file system format, using \$volume as the name of the destination
volume.

~

\$root and \$dest are in Zip (Unix) format.

~

\$volume is in local file system format.

~

For instance, under Windows,

~

\begin{verbatim}
   $zip->extractTree( 'a', 'd/e', 'f:' );
    
\end{verbatim}

~

when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will
extract:

~

a/x to f:d/e/x

~

a/b/c to f:d/e/b/c and ignore ax/d/e and d/e

~

If you want absolute paths (the prior example used paths relative to the
current directory on the destination volume, you can specify these in
\$dest:

~

\begin{verbatim}
   $zip->extractTree( 'a', '/d/e', 'f:' );
    
\end{verbatim}

~

when applied to a zip containing the files: a/x a/b/c ax/d/e d/e will
extract:

~

a/x to f:\textbackslash{}d\textbackslash{}e\textbackslash{}x

~

a/b/c to
f:\textbackslash{}d\textbackslash{}e\textbackslash{}b\textbackslash{}c
and ignore ax/d/e and d/e

~

Returns an error code or AZ\_OK if everything worked OK.
\end{description}

\hyperdef{}{MEMBERux5fOPERATIONS}{\section{\hyperref[MEMBERux5fOPERATIONS]{MEMBER
OPERATIONS}}\label{MEMBERux5fOPERATIONS}}

\hyperdef{}{Memberux5fClassux5fMethods}{\subsection{\hyperref[Memberux5fClassux5fMethods]{Member
Class Methods}}\label{Memberux5fClassux5fMethods}}

Several constructors allow you to construct members without adding them
to a zip archive. These work the same as the \emph{addFile()},
\emph{addDirectory()}, and \emph{addString()} zip instance methods
described above, but they don't add the new members to a zip.

\begin{description}
\item[Archive::Zip::Member-\textgreater{}newFromString(
\$stringOrStringRef {[}, \$fileName{]} )]
Construct a new member from the given string. Returns undef on error.

~

\begin{verbatim}
    my $member = Archive::Zip::Member->newFromString( 'This is a test',
                                                 'xyz.txt' );
    
\end{verbatim}
\end{description}

\begin{description}
\item[newFromFile( \$fileName )]
Construct a new member from the given file. Returns undef on error.

~

\begin{verbatim}
    my $member = Archive::Zip::Member->newFromFile( 'xyz.txt' );
    
\end{verbatim}
\end{description}

\begin{description}
\item[newDirectoryNamed( \$directoryName {[}, \$zipname {]} )]
Construct a new member from the given directory. \$directoryName must be
a valid name on your file system; it doesn't have to exist.

~

If given, \$zipname will be the name of the zip member; it must be a
valid Zip (Unix) name. If not given, it will be converted from
\$directoryName.

~

Returns undef on error.

~

\begin{verbatim}
    my $member = Archive::Zip::Member->newDirectoryNamed( 'CVS/' );
    
\end{verbatim}
\end{description}

\hyperdef{}{Memberux5fSimpleux5faccessors}{\subsection{\hyperref[Memberux5fSimpleux5faccessors]{Member
Simple accessors}}\label{Memberux5fSimpleux5faccessors}}

These methods get (and/or set) member attribute values.

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{versionMadeBy()}]
Gets the field from the member header.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[fileAttributeFormat( {[}\$format{]} )]
Gets or sets the field from the member header. These are ``FA\_*''
values.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{versionNeededToExtract()}]
Gets the field from the member header.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{bitFlag()}]
Gets the general purpose bit field from the member header. This is where
the ``GPBF\_*'' bits live.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{compressionMethod()}]
Returns the member compression method. This is the method that is
currently being used to compress the member data. This will be
COMPRESSION\_STORED for added string or file members, or any of the
``COMPRESSION\_*'' values for members from a zip file. However, this
module can only handle members whose data is in COMPRESSION\_STORED or
COMPRESSION\_DEFLATED format.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[desiredCompressionMethod( {[}\$method{]} )]
Get or set the member's ``desiredCompressionMethod''. This is the
compression method that will be used when the member is written. Returns
prior desiredCompressionMethod. Only COMPRESSION\_DEFLATED or
COMPRESSION\_STORED are valid arguments. Changing to COMPRESSION\_STORED
will change the member desiredCompressionLevel to 0; changing to
COMPRESSION\_DEFLATED will change the member desiredCompressionLevel to
COMPRESSION\_LEVEL\_DEFAULT.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[desiredCompressionLevel( {[}\$method{]} )]
Get or set the member's desiredCompressionLevel This is the method that
will be used to write. Returns prior desiredCompressionLevel. Valid
arguments are 0 through 9, COMPRESSION\_LEVEL\_NONE,
COMPRESSION\_LEVEL\_DEFAULT, COMPRESSION\_LEVEL\_BEST\_COMPRESSION, and
COMPRESSION\_LEVEL\_FASTEST. 0 or COMPRESSION\_LEVEL\_NONE will change
the desiredCompressionMethod to COMPRESSION\_STORED. All other arguments
will change the desiredCompressionMethod to COMPRESSION\_DEFLATED.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{externalFileName()}]
Return the member's external file name, if any, or undef.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{fileName()}]
Get or set the member's internal filename. Returns the (possibly new)
filename. Names will have backslashes converted to forward slashes, and
will have multiple consecutive slashes converted to single ones.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{lastModFileDateTime()}]
Return the member's last modification date/time stamp in MS-DOS format.
\end{description}

\begin{description}
\item[\emph{lastModTime()}]
Return the member's last modification date/time stamp, converted to unix
localtime format.

~

\begin{verbatim}
    print "Mod Time: " . scalar( localtime( $member->lastModTime() ) );
    
\end{verbatim}
\end{description}

\begin{description}
\item[\emph{setLastModFileDateTimeFromUnix()}]
Set the member's lastModFileDateTime from the given unix time.

~

\begin{verbatim}
    $member->setLastModFileDateTimeFromUnix( time() );
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{internalFileAttributes()}]
Return the internal file attributes field from the zip header. This is
only set for members read from a zip file.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{externalFileAttributes()}]
Return member attributes as read from the ZIP file. Note that these are
NOT UNIX!
\end{description}

\begin{description}
\item[unixFileAttributes( {[}\$newAttributes{]} )]
Get or set the member's file attributes using UNIX file attributes.
Returns old attributes.

~

\begin{verbatim}
    my $oldAttribs = $member->unixFileAttributes( 0666 );
    
\end{verbatim}

~

Note that the return value has more than just the file permissions, so
you will have to mask off the lowest bits for comparisions.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[localExtraField( {[}\$newField{]} )]
Gets or sets the extra field that was read from the local header. This
is not set for a member from a zip file until after the member has been
written out. The extra field must be in the proper format.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[cdExtraField( {[}\$newField{]} )]
Gets or sets the extra field that was read from the central directory
header. The extra field must be in the proper format.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{extraFields()}]
Return both local and CD extra fields, concatenated.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[fileComment( {[}\$newComment{]} )]
Get or set the member's file comment.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{hasDataDescriptor()}]
Get or set the data descriptor flag. If this is set, the local header
will not necessarily have the correct data sizes. Instead, a small
structure will be stored at the end of the member data with these
values. This should be transparent in normal operation.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{crc32()}]
Return the CRC-32 value for this member. This will not be set for
members that were constructed from strings or external files until after
the member has been written.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{crc32String()}]
Return the CRC-32 value for this member as an 8 character printable hex
string. This will not be set for members that were constructed from
strings or external files until after the member has been written.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{compressedSize()}]
Return the compressed size for this member. This will not be set for
members that were constructed from strings or external files until after
the member has been written.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{uncompressedSize()}]
Return the uncompressed size for this member.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{isEncrypted()}]
Return true if this member is encrypted. The Archive::Zip module does
not currently create or extract encrypted members.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[isTextFile( {[}\$flag{]} )]
Returns true if I am a text file. Also can set the status if given an
argument (then returns old state). Note that this module does not
currently do anything with this flag upon extraction or storage. That
is, bytes are stored in native format whether or not they came from a
text file.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{isBinaryFile()}]
Returns true if I am a binary file. Also can set the status if given an
argument (then returns old state). Note that this module does not
currently do anything with this flag upon extraction or storage. That
is, bytes are stored in native format whether or not they came from a
text file.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[extractToFileNamed( \$fileName )]
Extract me to a file with the given name. The file will be created with
default modes. Directories will be created as needed. The \$fileName
argument should be a valid file name on your file system. Returns AZ\_OK
on success.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{isDirectory()}]
Returns true if I am a directory.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{writeLocalHeaderRelativeOffset()}]
Returns the file offset in bytes the last time I was written.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{wasWritten()}]
Returns true if I was successfully written. Reset at the beginning of a
write attempt.
\end{description}

\hyperdef{}{Low-levelux5fmemberux5fdataux5freading}{\subsection{\hyperref[Low-levelux5fmemberux5fdataux5freading]{Low-level
member data reading}}\label{Low-levelux5fmemberux5fdataux5freading}}

It is possible to use lower-level routines to access member data
streams, rather than the extract* methods and \emph{contents()}. For
instance, here is how to print the uncompressed contents of a member in
chunks using these methods:

\begin{verbatim}
    my ( $member, $status, $bufferRef );
    $member = $zip->memberNamed( 'xyz.txt' );
    $member->desiredCompressionMethod( COMPRESSION_STORED );
    $status = $member->rewindData();
    die "error $status" unless $status == AZ_OK;
    while ( ! $member->readIsDone() )
    {
    ( $bufferRef, $status ) = $member->readChunk();
    die "error $status"
                if $status != AZ_OK && $status != AZ_STREAM_END;
    # do something with $bufferRef:
    print $$bufferRef;
    }
    $member->endRead();
\end{verbatim}

\begin{description}
\item[readChunk( {[}\$chunkSize{]} )]
This reads the next chunk of given size from the member's data stream
and compresses or uncompresses it as necessary, returning a reference to
the bytes read and a status. If size argument is not given, defaults to
global set by Archive::Zip::setChunkSize. Status is AZ\_OK on success
until the last chunk, where it returns AZ\_STREAM\_END. Returns ``(
\textbackslash{}\$bytes, \$status)''.

~

\begin{verbatim}
    my ( $outRef, $status ) = $self->readChunk();
    print $$outRef if $status != AZ_OK && $status != AZ_STREAM_END;
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{rewindData()}]
Rewind data and set up for reading data streams or writing zip files.
Can take options for ``inflateInit()'' or ``deflateInit()'', but this
isn't likely to be necessary. Subclass overrides should call this
method. Returns ``AZ\_OK'' on success.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{endRead()}]
Reset the read variables and free the inflater or deflater. Must be
called to close files, etc. Returns AZ\_OK on success.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{readIsDone()}]
Return true if the read has run out of data or errored out.
\end{description}

\begin{description}
\item[\emph{contents()}]
Return the entire uncompressed member data or undef in scalar context.
When called in array context, returns ``( \$string, \$status )''; status
will be AZ\_OK on success:

~

\begin{verbatim}
    my $string = $member->contents();
    # or
    my ( $string, $status ) = $member->contents();
    die "error $status" unless $status == AZ_OK;
    
\end{verbatim}

~

Can also be used to set the contents of a member (this may change the
class of the member):

~

\begin{verbatim}
    $member->contents( "this is my new contents" );
    
\end{verbatim}
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[extractToFileHandle( \$fh )]
Extract (and uncompress, if necessary) the member's contents to the
given file handle. Return AZ\_OK on success.
\end{description}

\hyperdef{}{Archive::Zip::FileMemberux5fmethods}{\section{\hyperref[Archive::Zip::FileMemberux5fmethods]{Archive::Zip::FileMember
methods}}\label{Archive::Zip::FileMemberux5fmethods}}

The Archive::Zip::FileMember class extends Archive::Zip::Member. It is
the base class for both ZipFileMember and NewFileMember classes. This
class adds an ``externalFileName'' and an ``fh'' member to keep track of
the external file.

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{externalFileName()}]
Return the member's external filename.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{fh()}]
Return the member's read file handle. Automatically opens file if
necessary.
\end{description}

\hyperdef{}{Archive::Zip::ZipFileMemberux5fmethods}{\section{\hyperref[Archive::Zip::ZipFileMemberux5fmethods]{Archive::Zip::ZipFileMember
methods}}\label{Archive::Zip::ZipFileMemberux5fmethods}}

The Archive::Zip::ZipFileMember class represents members that have been
read from external zip files.

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{diskNumberStart()}]
Returns the disk number that the member's local header resides in.
Should be 0.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{localHeaderRelativeOffset()}]
Returns the offset into the zip file where the member's local header is.
\end{description}

\begin{description}
\itemsep1pt\parskip0pt\parsep0pt
\item[\emph{dataOffset()}]
Returns the offset from the beginning of the zip file to the member's
data.
\end{description}

\hyperdef{}{REQUIREDux5fMODULES}{\section{\hyperref[REQUIREDux5fMODULES]{REQUIRED
MODULES}}\label{REQUIREDux5fMODULES}}

Archive::Zip requires several other modules:

Carp

Compress::Raw::Zlib

Cwd

File::Basename

File::Copy

File::Find

File::Path

File::Spec

IO::File

IO::Seekable

Time::Local

\hyperdef{}{BUGSux5fANDux5fCAVEATS}{\section{\hyperref[BUGSux5fANDux5fCAVEATS]{BUGS
AND CAVEATS}}\label{BUGSux5fANDux5fCAVEATS}}

\hyperdef{}{Whenux5fnotux5ftoux5fuseux5fArchive::Zip}{\subsection{\hyperref[Whenux5fnotux5ftoux5fuseux5fArchive::Zip]{When
not to use
Archive::Zip}}\label{Whenux5fnotux5ftoux5fuseux5fArchive::Zip}}

If you are just going to be extracting zips (and/or other archives) you
are recommended to look at using Archive::Extract instead, as it is much
easier to use and factors out archive-specific functionality.

\hyperdef{}{Tryux5ftoux5favoidux5fIO::Scalar}{\subsection{\hyperref[Tryux5ftoux5favoidux5fIO::Scalar]{Try
to avoid IO::Scalar}}\label{Tryux5ftoux5favoidux5fIO::Scalar}}

One of the most common ways to use Archive::Zip is to generate Zip files
in-memory. Most people have use IO::Scalar for this purpose.

Unfortunately, as of 1.11 this module no longer works with IO::Scalar as
it incorrectly implements seeking.

Anybody using IO::Scalar should consider porting to IO::String, which is
smaller, lighter, and is implemented to be perfectly compatible with
regular seekable filehandles.

Support for IO::Scalar most likely will \textbf{not} be restored in the
future, as IO::Scalar itself cannot change the way it is implemented due
to back-compatibility issues.

\hyperdef{}{TOux5fDO}{\section{\hyperref[TOux5fDO]{TO
DO}}\label{TOux5fDO}}

* auto-choosing storing vs compression

* extra field hooks (see notes.txt)

* check for dups on addition/renaming?

* Text file extraction (line end translation)

* Reading zip files from non-seekable inputs \\ (Perhaps by proxying
through IO::String?)

* separate unused constants into separate module

* cookbook style docs

* Handle tainted paths correctly

* Work on better compatibility with other IO:: modules

\hyperdef{}{SUPPORT}{\section{\hyperref[SUPPORT]{SUPPORT}}\label{SUPPORT}}

Bugs should be reported via the CPAN bug tracker

http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive-Zip
\textless{}http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive-Zip\textgreater{}

For other issues contact the maintainer

\hyperdef{}{AUTHOR}{\section{\hyperref[AUTHOR]{AUTHOR}}\label{AUTHOR}}

Adam Kennedy \textless{}adamk@cpan.org\textgreater{}

Previously maintained by Steve Peters
\textless{}steve@fisharerojo.org\textgreater{}.

File attributes code by Maurice Aubrey
\textless{}maurice@lovelyfilth.com\textgreater{}.

Originally by Ned Konz \textless{}nedkonz@cpan.org\textgreater{}.

\hyperdef{}{COPYRIGHT}{\section{\hyperref[COPYRIGHT]{COPYRIGHT}}\label{COPYRIGHT}}

Some parts copyright 2006 - 2009 Adam Kennedy.

Some parts copyright 2005 Steve Peters.

Original work copyright 2000 - 2004 Ned Konz.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

\hyperdef{}{SEEux5fALSO}{\section{\hyperref[SEEux5fALSO]{SEE
ALSO}}\label{SEEux5fALSO}}

Look at Archive::Zip::MemberRead which is a wrapper that allows one to
read Zip archive members as if they were files.

Compress::Raw::Zlib, Archive::Tar, Archive::Extract

There is a Japanese translation of this document at
http://www.memb.jp/\textasciitilde{}deq/perl/doc-ja/Archive-Zip.html
\textless{}http://www.memb.jp/\textasciitilde{}deq/perl/doc-ja/Archive-Zip.html\textgreater{}
that was done by DEQ \textless{}deq@oct.zaq.ne.jp\textgreater{} .
Thanks!

\begin{longtable}[c]{@{}ll@{}}
\toprule\addlinespace
2013-06-12 & perl v5.14.2
\\\addlinespace
\bottomrule
\end{longtable}

\end{document}
